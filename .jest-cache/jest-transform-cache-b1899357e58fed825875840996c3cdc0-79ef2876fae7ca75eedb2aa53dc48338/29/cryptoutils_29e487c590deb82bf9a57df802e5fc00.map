{"file":"/Volumes/MAC_APP/openmake_llm/database/models/crypto-utils.ts","mappings":"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","names":[],"sources":["/Volumes/MAC_APP/openmake_llm/database/models/crypto-utils.ts"],"sourcesContent":["/**\n * #1 개선: 토큰 암호화 유틸리티\n * AES-256-GCM을 사용한 at-rest 암호화\n */\n\nimport * as crypto from 'crypto';\n\nconst ALGORITHM = 'aes-256-gcm';\nconst IV_LENGTH = 16;\nconst AUTH_TAG_LENGTH = 16;\n\n/**\n * 암호화 키 획득 (환경변수에서 로드)\n * 32바이트 = 256비트 키 필요\n */\nfunction getEncryptionKey(): Buffer {\n    const key = process.env.TOKEN_ENCRYPTION_KEY;\n    if (key) {\n        // hex 문자열이면 Buffer로 변환\n        if (key.length === 64) {\n            return Buffer.from(key, 'hex');\n        }\n        // 문자열이면 SHA-256 해시로 32바이트 키 생성\n        return crypto.createHash('sha256').update(key).digest();\n    }\n\n    // 환경변수 없으면 JWT_SECRET에서 파생\n    const jwtSecret = process.env.JWT_SECRET;\n    if (jwtSecret) {\n        return crypto.createHash('sha256').update(jwtSecret).digest();\n    }\n\n    // 개발 환경 폴백 (프로덕션에서는 경고)\n    if (process.env.NODE_ENV === 'production') {\n        console.error('[Crypto] TOKEN_ENCRYPTION_KEY 또는 JWT_SECRET이 설정되지 않았습니다!');\n    }\n    return crypto.createHash('sha256').update('dev-fallback-key-do-not-use-in-production').digest();\n}\n\n/**\n * 문자열 암호화\n * @returns `iv:authTag:encryptedData` 형식의 hex 문자열\n */\nexport function encrypt(plaintext: string): string {\n    if (!plaintext) return plaintext;\n\n    const key = getEncryptionKey();\n    const iv = crypto.randomBytes(IV_LENGTH);\n    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);\n\n    let encrypted = cipher.update(plaintext, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    const authTag = cipher.getAuthTag();\n\n    return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}`;\n}\n\n/**\n * 암호화된 문자열 복호화\n * @param ciphertext `iv:authTag:encryptedData` 형식의 hex 문자열\n */\nexport function decrypt(ciphertext: string): string {\n    if (!ciphertext) return ciphertext;\n\n    // 이미 암호화되지 않은 값인 경우 (마이그레이션 호환)\n    if (!ciphertext.includes(':')) {\n        return ciphertext;\n    }\n\n    const parts = ciphertext.split(':');\n    if (parts.length !== 3) {\n        // 형식이 맞지 않으면 원본 반환 (마이그레이션 호환)\n        return ciphertext;\n    }\n\n    try {\n        const key = getEncryptionKey();\n        const iv = Buffer.from(parts[0], 'hex');\n        const authTag = Buffer.from(parts[1], 'hex');\n        const encryptedData = parts[2];\n\n        const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);\n        decipher.setAuthTag(authTag);\n\n        let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n        decrypted += decipher.final('utf8');\n\n        return decrypted;\n    } catch (e) {\n        // 복호화 실패 시 원본 반환 (마이그레이션 호환)\n        console.warn('[Crypto] 복호화 실패 - 평문으로 간주합니다');\n        return ciphertext;\n    }\n}\n"],"version":3}