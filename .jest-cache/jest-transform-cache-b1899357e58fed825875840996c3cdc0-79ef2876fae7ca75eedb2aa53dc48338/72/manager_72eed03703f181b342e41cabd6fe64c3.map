{"file":"/Volumes/MAC_APP/openmake_llm/backend/api/src/cluster/manager.ts","mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;GAsBG;;;;;;;;;;;;AAiaH,8CAKC;AAUD,oDAEC;AAhbD,mCAAsC;AACtC,+BAAoC;AAQpC,qCAA6C;AAC7C,6CAA8D;AAE9D;;;;;;;;;;;;;;;;;;;;;;;GAuBG;AACH,MAAa,cAAe,SAAQ,qBAAY;IAgB5C;;;;OAIG;IACH,YAAY,MAA+B;QACvC,KAAK,EAAE,CAAC;QArBZ,+BAA+B;QACvB,UAAK,GAA6B,IAAI,GAAG,EAAE,CAAC;QAEpD,yBAAyB;QACjB,YAAO,GAA8B,IAAI,GAAG,EAAE,CAAC;QAkBnD,IAAI,CAAC,MAAM,mCAAQ,IAAA,0BAAiB,GAAE,GAAK,MAAM,CAAE,CAAC;QACpD,IAAI,CAAC,MAAM,GAAG,IAAA,SAAM,GAAE,CAAC;IAC3B,CAAC;IAED;;;OAGG;IACH,IAAI,EAAE;QACF,OAAO,IAAI,CAAC,MAAM,CAAC;IACvB,CAAC;IAED;;;OAGG;IACH,IAAI,WAAW;QACX,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;IAC5B,CAAC;IAED;;;;;;;;;;;;;OAaG;IACG,KAAK;;YACP,YAAY;YACZ,KAAK,MAAM,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;gBACzC,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAC;YAC1E,CAAC;YAED,cAAc;YACd,IAAI,CAAC,gBAAgB,EAAE,CAAC;QAC5B,CAAC;KAAA;IAED;;;;OAIG;IACH,IAAI;QACA,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC3B,aAAa,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YACxC,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;QACzC,CAAC;QACD,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QACnB,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;IACzB,CAAC;IAED;;;;;;;;;;;;;;;;;;OAkBG;IACG,OAAO,CAAC,IAAY,EAAE,IAAY,EAAE,IAAa;;YACnD,MAAM,MAAM,GAAG,GAAG,IAAI,IAAI,IAAI,EAAE,CAAC;YAEjC,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC;gBACzB,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC;YACnC,CAAC;YAED,MAAM,MAAM,GAAG,IAAA,qBAAY,EAAC;gBACxB,OAAO,EAAE,UAAU,IAAI,IAAI,IAAI,EAAE;aACpC,CAAC,CAAC;YAEH,SAAS;YACT,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,WAAW,EAAE,CAAC;YAE/C,MAAM,IAAI,GAAgB;gBACtB,EAAE,EAAE,MAAM;gBACV,IAAI,EAAE,IAAI,IAAI,MAAM;gBACpB,IAAI;gBACJ,IAAI;gBACJ,MAAM,EAAE,WAAW,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;gBAC1C,MAAM,EAAE,EAAE;gBACV,SAAS,EAAE,EAAE;gBACb,QAAQ,EAAE,IAAI,IAAI,EAAE;aACvB,CAAC;YAEF,IAAI,WAAW,EAAE,CAAC;gBACd,aAAa;gBACb,IAAI,CAAC;oBACD,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,UAAU,EAAE,CAAC;oBAC3C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBACnD,CAAC;gBAAC,OAAO,CAAM,EAAE,CAAC;oBACd,mBAAmB;oBACnB,OAAO,CAAC,KAAK,CAAC,aAAa,MAAM,eAAe,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC;gBACtE,CAAC;gBAED,UAAU;gBACV,IAAI,CAAC,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;YACrD,CAAC;YAED,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YAC7B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YAEjC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,aAAa,EAAE,IAAI,EAAkB,CAAC,CAAC;YAElE,OAAO,IAAI,CAAC;QAChB,CAAC;KAAA;IAED;;;;;;;OAOG;IACH,UAAU,CAAC,MAAc;QACrB,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAC1C,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAE5B,IAAI,OAAO,EAAE,CAAC;YACV,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,cAAc,EAAE,MAAM,EAAkB,CAAC,CAAC;QACzE,CAAC;QAED,OAAO,OAAO,CAAC;IACnB,CAAC;IAED;;;;OAIG;IACH,QAAQ;QACJ,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC;IAC3C,CAAC;IAED;;;;OAIG;IACH,cAAc;QACV,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC;IAC9D,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACH,iBAAiB,CAAC,SAAiB;QAC/B,OAAO,IAAI,CAAC,cAAc,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CACpC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAC5C,CAAC;IACN,CAAC;IAED;;;;;OAKG;IACH,SAAS,CAAC,MAAc;QACpB,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACH,WAAW,CAAC,SAAkB;QAC1B,IAAI,UAAU,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACvC,OAAO,CAAC,GAAG,CAAC,qCAAqC,SAAS,mBAAmB,UAAU,CAAC,MAAM,EAAE,CAAC,CAAC;QAClG,UAAU,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,MAAM,aAAa,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;QAE3G,kCAAkC;QAClC,IAAI,SAAS,IAAI,SAAS,KAAK,SAAS,EAAE,CAAC;YACvC,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAC/B,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAC5C,CAAC;YACF,OAAO,CAAC,GAAG,CAAC,kCAAkC,UAAU,CAAC,MAAM,EAAE,CAAC,CAAC;QACvE,CAAC;QAED,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,SAAS,CAAC;QAE9C,oBAAoB;QACpB,OAAO,UAAU,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;YACpC,IAAI,CAAC,IAAI;gBAAE,OAAO,IAAI,CAAC;YACvB,IAAI,CAAC,IAAI,CAAC,OAAO,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,IAAI,QAAQ,CAAC,EAAE,CAAC;gBAC1D,OAAO,IAAI,CAAC;YAChB,CAAC;YACD,OAAO,IAAI,CAAC;QAChB,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;;;;OAaG;IACH,QAAQ;QACJ,MAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC9B,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,KAAK,QAAQ,CAAC,CAAC;QAC7D,MAAM,SAAS,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC;QACrD,MAAM,YAAY,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;QAE7C,OAAO;YACH,UAAU,EAAE,KAAK,CAAC,MAAM;YACxB,WAAW,EAAE,WAAW,CAAC,MAAM;YAC/B,WAAW,EAAE,SAAS,CAAC,MAAM;YAC7B,YAAY;SACf,CAAC;IACN,CAAC;IAED;;;;;;;OAOG;IACW,cAAc,CAAC,MAAoB;;YAC7C,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YACzB,IAAI,CAAC;gBACD,MAAM,MAAM,CAAC,WAAW,EAAE,CAAC;gBAC3B,OAAO,IAAI,CAAC,GAAG,EAAE,GAAG,KAAK,CAAC;YAC9B,CAAC;YAAC,WAAM,CAAC;gBACL,OAAO,QAAQ,CAAC;YACpB,CAAC;QACL,CAAC;KAAA;IAED;;;;;;;;;;OAUG;IACW,gBAAgB,CAAC,MAAc;;YACzC,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YACpC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAExC,IAAI,CAAC,IAAI,IAAI,CAAC,MAAM;gBAAE,OAAO;YAE7B,MAAM,SAAS,GAAG,IAAI,CAAC,MAAM,KAAK,QAAQ,CAAC;YAC3C,MAAM,WAAW,GAAG,MAAM,MAAM,CAAC,WAAW,EAAE,CAAC;YAE/C,IAAI,CAAC,MAAM,GAAG,WAAW,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS,CAAC;YACjD,IAAI,CAAC,QAAQ,GAAG,WAAW,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;YAEzD,IAAI,WAAW,EAAE,CAAC;gBACd,WAAW;gBACX,IAAI,CAAC;oBACD,MAAM,QAAQ,GAAG,MAAM,MAAM,CAAC,UAAU,EAAE,CAAC;oBAC3C,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;gBACnD,CAAC;gBAAC,OAAO,CAAM,EAAE,CAAC;oBACd,mBAAmB;oBACnB,OAAO,CAAC,KAAK,CAAC,aAAa,MAAM,YAAY,EAAE,CAAC,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC;gBACnE,CAAC;gBACD,IAAI,CAAC,OAAO,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;YACrD,CAAC;YAED,YAAY;YACZ,IAAI,SAAS,KAAK,WAAW,EAAE,CAAC;gBAC5B,IAAI,WAAW,EAAE,CAAC;oBACd,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,aAAa,EAAE,IAAI,EAAkB,CAAC,CAAC;gBACtE,CAAC;qBAAM,CAAC;oBACJ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,cAAc,EAAE,MAAM,EAAkB,CAAC,CAAC;gBACzE,CAAC;YACL,CAAC;iBAAM,CAAC;gBACJ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,cAAc,EAAE,IAAI,EAAkB,CAAC,CAAC;YACvE,CAAC;QACL,CAAC;KAAA;IAED;;;;OAIG;IACK,gBAAgB;QACpB,IAAI,CAAC,mBAAmB,GAAG,WAAW,CAAC,GAAS,EAAE;YAC9C,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;YAC9C,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QACpE,CAAC,CAAA,EAAE,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,CAAC;IACtC,CAAC;CACJ;AAzWD,wCAyWC;AAED,8BAA8B;AAC9B,IAAI,eAAe,GAA0B,IAAI,CAAC;AAElD;;;;;;;;;;;;GAYG;AACH,SAAgB,iBAAiB;IAC7B,IAAI,CAAC,eAAe,EAAE,CAAC;QACnB,eAAe,GAAG,IAAI,cAAc,EAAE,CAAC;IAC3C,CAAC;IACD,OAAO,eAAe,CAAC;AAC3B,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,oBAAoB,CAAC,MAA+B;IAChE,OAAO,IAAI,cAAc,CAAC,MAAM,CAAC,CAAC;AACtC,CAAC","names":[],"sources":["/Volumes/MAC_APP/openmake_llm/backend/api/src/cluster/manager.ts"],"sourcesContent":["/**\n * @fileoverview Ollama 클러스터 관리 모듈\n * \n * 분산 Ollama 노드들을 관리하는 클러스터 매니저입니다.\n * 노드 등록/제거, 헬스체크, 레이턴시 기반 최적 노드 선택 기능을 제공합니다.\n * \n * @module cluster/manager\n * \n * @example\n * ```typescript\n * import { getClusterManager } from './manager';\n * \n * const cluster = getClusterManager();\n * await cluster.start();\n * \n * // 특정 모델을 가진 최적의 노드 선택\n * const bestNode = cluster.getBestNode('llama3');\n * if (bestNode) {\n *   const client = cluster.getClient(bestNode.id);\n *   // client를 사용하여 요청 처리\n * }\n * ```\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n    ClusterNode,\n    ClusterConfig,\n    ClusterStats,\n    ClusterEvent,\n    NodeResources\n} from './types';\nimport { loadClusterConfig } from './config';\nimport { createClient, OllamaClient } from '../ollama/client';\n\n/**\n * Ollama 클러스터 관리자\n * \n * 여러 Ollama 노드를 관리하고 모니터링합니다.\n * EventEmitter를 상속하여 노드 상태 변경 이벤트를 발생시킵니다.\n * \n * @class ClusterManager\n * @extends EventEmitter\n * \n * @fires ClusterManager#event:node:online - 노드가 온라인 상태가 됨\n * @fires ClusterManager#event:node:offline - 노드가 오프라인 상태가 됨\n * @fires ClusterManager#event:node:updated - 노드 정보가 업데이트됨\n * \n * @example\n * ```typescript\n * const cluster = new ClusterManager({ heartbeatInterval: 30000 });\n * cluster.on('event', (event) => {\n *   if (event.type === 'node:offline') {\n *     console.warn(`노드 오프라인: ${event.nodeId}`);\n *   }\n * });\n * await cluster.start();\n * ```\n */\nexport class ClusterManager extends EventEmitter {\n    /** 등록된 노드 맵 (노드ID -> 노드 정보) */\n    private nodes: Map<string, ClusterNode> = new Map();\n    \n    /** 노드별 Ollama 클라이언트 맵 */\n    private clients: Map<string, OllamaClient> = new Map();\n    \n    /** 클러스터 설정 */\n    private config: ClusterConfig;\n    \n    /** 헬스체크 인터벌 타이머 */\n    private healthCheckInterval?: NodeJS.Timeout;\n    \n    /** 이 매니저 인스턴스의 고유 ID */\n    private nodeId: string;\n\n    /**\n     * ClusterManager 인스턴스 생성\n     * \n     * @param config - 클러스터 설정 (선택적, 기본 설정과 병합됨)\n     */\n    constructor(config?: Partial<ClusterConfig>) {\n        super();\n        this.config = { ...loadClusterConfig(), ...config };\n        this.nodeId = uuidv4();\n    }\n\n    /**\n     * 클러스터 매니저 인스턴스 ID\n     * @returns 고유 UUID 문자열\n     */\n    get id(): string {\n        return this.nodeId;\n    }\n\n    /**\n     * 클러스터 이름\n     * @returns 설정된 클러스터 이름\n     */\n    get clusterName(): string {\n        return this.config.name;\n    }\n\r\n    /**\n     * 클러스터 시작\n     * \n     * 설정에 정의된 정적 노드들을 등록하고 주기적 헬스체크를 시작합니다.\n     * \n     * @returns Promise<void>\n     * \n     * @example\n     * ```typescript\n     * const cluster = getClusterManager();\n     * await cluster.start();\n     * console.log('클러스터 시작됨:', cluster.getStats());\n     * ```\n     */\n    async start(): Promise<void> {\n        // 정적 노드들 등록\r\n        for (const staticNode of this.config.nodes) {\r\n            await this.addNode(staticNode.host, staticNode.port, staticNode.name);\r\n        }\r\n\r\n        // 주기적 헬스체크 시작\r\n        this.startHealthCheck();\r\n    }\r\n\r\n    /**\n     * 클러스터 중지\n     * \n     * 헬스체크를 중단하고 모든 노드 및 클라이언트 정보를 정리합니다.\n     */\n    stop(): void {\n        if (this.healthCheckInterval) {\r\n            clearInterval(this.healthCheckInterval);\r\n            this.healthCheckInterval = undefined;\r\n        }\r\n        this.nodes.clear();\r\n        this.clients.clear();\r\n    }\r\n\r\n    /**\n     * 노드 추가\n     * \n     * 새로운 Ollama 노드를 클러스터에 추가합니다.\n     * 연결 테스트 후 온라인/오프라인 상태를 설정합니다.\n     * \n     * @param host - 노드 호스트 주소\n     * @param port - 노드 포트 번호\n     * @param name - 노드 별칭 (선택, 기본값: \"host:port\")\n     * @returns 추가된 노드 정보 또는 null (이미 존재하는 경우)\n     * \n     * @example\n     * ```typescript\n     * const node = await cluster.addNode('192.168.1.100', 11434, 'gpu-server');\n     * if (node) {\n     *   console.log(`노드 추가됨: ${node.name} (${node.status})`);\n     * }\n     * ```\n     */\n    async addNode(host: string, port: number, name?: string): Promise<ClusterNode | null> {\n        const nodeId = `${host}:${port}`;\r\n\r\n        if (this.nodes.has(nodeId)) {\r\n            return this.nodes.get(nodeId)!;\r\n        }\r\n\r\n        const client = createClient({\r\n            baseUrl: `http://${host}:${port}`\r\n        });\r\n\r\n        // 연결 테스트\r\n        const isAvailable = await client.isAvailable();\r\n\r\n        const node: ClusterNode = {\r\n            id: nodeId,\r\n            name: name || nodeId,\r\n            host,\r\n            port,\r\n            status: isAvailable ? 'online' : 'offline',\r\n            models: [],\r\n            resources: {},\r\n            lastSeen: new Date()\r\n        };\r\n\r\n        if (isAvailable) {\r\n            // 모델 목록 가져오기\r\n            try {\r\n                const response = await client.listModels();\r\n                node.models = response.models.map(m => m.name);\r\n            } catch (e: any) {\r\n                // 모델 목록 조회 실패 - 로깅\r\n                console.debug(`[Cluster] ${nodeId} 모델 목록 조회 실패:`, e.message || e);\r\n            }\r\n\r\n            // 레이턴시 측정\r\n            node.latency = await this.measureLatency(client);\r\n        }\r\n\r\n        this.nodes.set(nodeId, node);\r\n        this.clients.set(nodeId, client);\r\n\r\n        this.emit('event', { type: 'node:online', node } as ClusterEvent);\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\n     * 노드 제거\n     * \n     * 클러스터에서 노드를 제거합니다.\n     * \n     * @param nodeId - 제거할 노드 ID (\"host:port\" 형식)\n     * @returns 제거 성공 여부\n     */\n    removeNode(nodeId: string): boolean {\n        const existed = this.nodes.delete(nodeId);\r\n        this.clients.delete(nodeId);\r\n\r\n        if (existed) {\r\n            this.emit('event', { type: 'node:offline', nodeId } as ClusterEvent);\r\n        }\r\n\r\n        return existed;\r\n    }\r\n\r\n    /**\n     * 모든 노드 조회\n     * \n     * @returns 등록된 모든 노드 배열 (온라인/오프라인 모두 포함)\n     */\n    getNodes(): ClusterNode[] {\n        return Array.from(this.nodes.values());\n    }\n\n    /**\n     * 온라인 노드만 조회\n     * \n     * @returns 현재 온라인 상태인 노드들만 반환\n     */\n    getOnlineNodes(): ClusterNode[] {\n        return this.getNodes().filter(n => n.status === 'online');\n    }\n\n    /**\n     * 특정 모델을 가진 노드 조회\n     * \n     * 지정된 모델이 설치된 온라인 노드들을 반환합니다.\n     * 모델명은 부분 일치로 검색됩니다.\n     * \n     * @param modelName - 검색할 모델 이름 (부분 일치)\n     * @returns 해당 모델을 가진 온라인 노드 배열\n     * \n     * @example\n     * ```typescript\n     * const llamaNodes = cluster.getNodesWithModel('llama');\n     * // llama3, llama2, codellama 등 'llama'가 포함된 모델을 가진 노드들 반환\n     * ```\n     */\n    getNodesWithModel(modelName: string): ClusterNode[] {\n        return this.getOnlineNodes().filter(n =>\n            n.models.some(m => m.includes(modelName))\n        );\n    }\n\n    /**\n     * 노드의 Ollama 클라이언트 가져오기\n     * \n     * @param nodeId - 노드 ID\n     * @returns 해당 노드의 OllamaClient 또는 undefined\n     */\n    getClient(nodeId: string): OllamaClient | undefined {\n        return this.clients.get(nodeId);\n    }\n\n    /**\n     * 최적의 노드 선택 (레이턴시 기반)\n     * \n     * 온라인 노드 중 레이턴시가 가장 낮은 노드를 선택합니다.\n     * 모델명이 지정되면 해당 모델을 가진 노드들 중에서 선택합니다.\n     * \n     * @param modelName - 필요한 모델 이름 (선택, \"default\"는 무시됨)\n     * @returns 최적의 노드 또는 undefined (후보 없음)\n     * \n     * @example\n     * ```typescript\n     * const node = cluster.getBestNode('gemma:2b');\n     * if (node) {\n     *   console.log(`최적 노드: ${node.name}, 레이턴시: ${node.latency}ms`);\n     * }\n     * ```\n     */\n    getBestNode(modelName?: string): ClusterNode | undefined {\n        let candidates = this.getOnlineNodes();\r\n        console.log(`[Cluster] getBestNode 호출 - model: ${modelName}, online nodes: ${candidates.length}`);\r\n        candidates.forEach(n => console.log(`[Cluster]   - ${n.id}: ${n.status}, models: ${n.models.join(', ')}`));\r\n\r\n        // \"default\"는 특별한 값이므로 모델 필터링을 건너뜀\r\n        if (modelName && modelName !== 'default') {\r\n            candidates = candidates.filter(n =>\r\n                n.models.some(m => m.includes(modelName))\r\n            );\r\n            console.log(`[Cluster] 모델 필터링 후 candidates: ${candidates.length}`);\r\n        }\r\n\r\n        if (candidates.length === 0) return undefined;\r\n\r\n        // 레이턴시가 가장 낮은 노드 선택\r\n        return candidates.reduce((best, node) => {\r\n            if (!best) return node;\r\n            if ((node.latency || Infinity) < (best.latency || Infinity)) {\r\n                return node;\r\n            }\r\n            return best;\r\n        });\r\n    }\r\n\r\n    /**\n     * 클러스터 통계 조회\n     * \n     * 현재 클러스터의 전체 상태 요약을 반환합니다.\n     * \n     * @returns 클러스터 통계 객체\n     * \n     * @example\n     * ```typescript\n     * const stats = cluster.getStats();\n     * console.log(`전체 노드: ${stats.totalNodes}, 온라인: ${stats.onlineNodes}`);\n     * console.log(`사용 가능한 모델: ${stats.uniqueModels.join(', ')}`);\n     * ```\n     */\n    getStats(): ClusterStats {\n        const nodes = this.getNodes();\r\n        const onlineNodes = nodes.filter(n => n.status === 'online');\r\n        const allModels = onlineNodes.flatMap(n => n.models);\r\n        const uniqueModels = [...new Set(allModels)];\r\n\r\n        return {\r\n            totalNodes: nodes.length,\r\n            onlineNodes: onlineNodes.length,\r\n            totalModels: allModels.length,\r\n            uniqueModels\r\n        };\r\n    }\r\n\r\n    /**\n     * 레이턴시 측정\n     * \n     * 노드까지의 왕복 시간을 측정합니다.\n     * \n     * @param client - 측정 대상 Ollama 클라이언트\n     * @returns 레이턴시(ms) 또는 Infinity (연결 실패 시)\n     */\n    private async measureLatency(client: OllamaClient): Promise<number> {\n        const start = Date.now();\r\n        try {\r\n            await client.isAvailable();\r\n            return Date.now() - start;\r\n        } catch {\r\n            return Infinity;\r\n        }\r\n    }\r\n\r\n    /**\n     * 노드 상태 업데이트\n     * \n     * 노드의 온라인/오프라인 상태, 모델 목록, 레이턴시를 갱신합니다.\n     * 상태 변경 시 적절한 이벤트를 발생시킵니다.\n     * \n     * @param nodeId - 업데이트할 노드 ID\n     * @fires ClusterManager#event:node:online\n     * @fires ClusterManager#event:node:offline\n     * @fires ClusterManager#event:node:updated\n     */\n    private async updateNodeStatus(nodeId: string): Promise<void> {\n        const node = this.nodes.get(nodeId);\r\n        const client = this.clients.get(nodeId);\r\n\r\n        if (!node || !client) return;\r\n\r\n        const wasOnline = node.status === 'online';\r\n        const isAvailable = await client.isAvailable();\r\n\r\n        node.status = isAvailable ? 'online' : 'offline';\r\n        node.lastSeen = isAvailable ? new Date() : node.lastSeen;\r\n\r\n        if (isAvailable) {\r\n            // 모델 목록 갱신\r\n            try {\r\n                const response = await client.listModels();\r\n                node.models = response.models.map(m => m.name);\r\n            } catch (e: any) {\r\n                // 모델 목록 갱신 실패 - 로깅\r\n                console.debug(`[Cluster] ${nodeId} 모델 갱신 실패:`, e.message || e);\r\n            }\r\n            node.latency = await this.measureLatency(client);\r\n        }\r\n\r\n        // 상태 변경 이벤트\r\n        if (wasOnline !== isAvailable) {\r\n            if (isAvailable) {\r\n                this.emit('event', { type: 'node:online', node } as ClusterEvent);\r\n            } else {\r\n                this.emit('event', { type: 'node:offline', nodeId } as ClusterEvent);\r\n            }\r\n        } else {\r\n            this.emit('event', { type: 'node:updated', node } as ClusterEvent);\r\n        }\r\n    }\r\n\r\n    /**\n     * 헬스체크 시작\n     * \n     * 설정된 간격으로 모든 노드의 상태를 확인하는 인터벌을 시작합니다.\n     */\n    private startHealthCheck(): void {\n        this.healthCheckInterval = setInterval(async () => {\r\n            const nodeIds = Array.from(this.nodes.keys());\r\n            await Promise.all(nodeIds.map(id => this.updateNodeStatus(id)));\r\n        }, this.config.heartbeatInterval);\r\n    }\r\n}\r\n\r\n/** 싱글톤 ClusterManager 인스턴스 */\nlet clusterInstance: ClusterManager | null = null;\n\n/**\n * ClusterManager 싱글톤 인스턴스 획득\n * \n * 애플리케이션 전역에서 동일한 클러스터 매니저를 사용할 수 있습니다.\n * \n * @returns ClusterManager 싱글톤 인스턴스\n * \n * @example\n * ```typescript\n * const cluster = getClusterManager();\n * await cluster.start();\n * ```\n */\nexport function getClusterManager(): ClusterManager {\n    if (!clusterInstance) {\n        clusterInstance = new ClusterManager();\n    }\n    return clusterInstance;\n}\n\n/**\n * 새로운 ClusterManager 인스턴스 생성\n * \n * 싱글톤이 아닌 독립적인 클러스터 매니저가 필요할 때 사용합니다.\n * \n * @param config - 클러스터 설정 (선택)\n * @returns 새로운 ClusterManager 인스턴스\n */\nexport function createClusterManager(config?: Partial<ClusterConfig>): ClusterManager {\n    return new ClusterManager(config);\n}\n"],"version":3}